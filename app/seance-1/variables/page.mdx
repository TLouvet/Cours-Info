# Variables & Types

En JavaScript moderne, nous utilisons `let` et `const` pour d√©clarer des variables.

<Callout type="error" title="var - OBSOL√àTE">
**Ne jamais utiliser `var` !**

Utilisez toujours `let` ou `const`.
</Callout>

## Pourquoi var est obsol√®te ?

`var` √©tait la seule fa√ßon de d√©clarer des variables avant ES6 (2015). Mais il a des probl√®mes majeurs :

### Probl√®me 1 : Port√©e (scope) bizarre

```javascript
// var a une port√©e de fonction, pas de bloc
if (true) {
  var x = 10;
}
console.log(x); // 10 - accessible en dehors du if ! üò±

// let/const ont une port√©e de bloc (plus logique)
if (true) {
  let y = 10;
}
console.log(y); // ‚ùå ReferenceError: y is not defined
```

### Probl√®me 2 : Hoisting (remont√©e)

```javascript
// var est "remont√©" au d√©but de la fonction
console.log(name); // undefined (pas d'erreur!)
var name = 'Alice';

// let/const donnent une erreur claire
console.log(age); // ‚ùå ReferenceError: Cannot access 'age' before initialization
let age = 25;
```

### Probl√®me 3 : Red√©claration possible

```javascript
// var permet de red√©clarer la m√™me variable
var count = 1;
var count = 2; // Pas d'erreur üò±
console.log(count); // 2

// let/const emp√™chent la red√©claration
let score = 1;
let score = 2; // ‚ùå SyntaxError: Identifier 'score' has already been declared
```

### Probl√®me 4 : Pollution du scope global

```javascript
// var dans le scope global devient une propri√©t√© de window
var globalVar = 'danger';
console.log(window.globalVar); // 'danger' üò±

// let/const restent dans leur scope
let globalLet = 'safe';
console.log(window.globalLet); // undefined ‚úÖ
```

<Callout type="success" title="Solution moderne">
**Toujours utiliser :**
- `const` par d√©faut (valeur qui ne change pas)
- `let` seulement si vous devez r√©assigner

**Ne jamais utiliser `var`** - c'est du code ancien (pre-2015).
</Callout>

## Types primitifs

JavaScript a plusieurs types de base.

### number

```javascript
const age = 25;
const pi = 3.14;
const negatif = -7;
const infini = Infinity;
const pasUnNombre = NaN; // Not a Number
```

<Callout type="tip">
JavaScript n'a qu'un seul type num√©rique (64 bits). Pas de distinction int/float/double.
</Callout>

### string

Les cha√Ænes de caract√®res repr√©sentent du texte.

```javascript
const simple = 'Hello';
const double = "World";
const template = `Hello ${simple}`;
```

<Callout type="info">
Les strings seront d√©taill√©s dans la page suivante avec les template literals !
</Callout>

### boolean

```javascript
const vrai = true;
const faux = false;
```

### undefined et null

```javascript
let x; // undefined (d√©clar√© mais non assign√©)
const y = null; // null (absence volontaire de valeur)
```

<QuickCheck
  question="Quelle est la diff√©rence entre undefined et null ?"
  options={[
    "undefined = non initialis√©, null = volontairement vide",
    "undefined = erreur, null = valeur valide",
    "C'est la m√™me chose",
    "undefined pour les objets, null pour les primitifs"
  ]}
  correctAnswer={0}
  explanation="undefined signifie qu'une variable n'a pas encore re√ßu de valeur, tandis que null est une assignation explicite indiquant 'pas de valeur'."
/>

### typeof

L'op√©rateur `typeof` permet de v√©rifier le type d'une valeur.

```javascript
typeof 42;        // "number"
typeof "hello";   // "string"
typeof true;      // "boolean"
typeof undefined; // "undefined"
typeof null;      // "object" (bug historique!)
```

<Callout type="warning" title="Bug historique">
`typeof null` retourne `"object"` au lieu de `"null"`. C'est un bug qui date de la cr√©ation de JavaScript et qui n'a jamais √©t√© corrig√© pour des raisons de compatibilit√©.

Pour v√©rifier si une valeur est `null`, utilisez `=== null` directement.
</Callout>

## D√©claration de variables

### let - Variable

Peut √™tre r√©assign√©e.

```javascript
let count = 0;
count = 1; // OK
count = count + 1; // OK
```

**Utilisez `let` quand :**
- La valeur va changer (compteur, accumulation)
- Dans une boucle
- Pour des valeurs temporaires

### const - Constante

Ne peut **pas** √™tre r√©assign√©e.

```javascript
const PI = 3.14;
PI = 3; // ‚ùå Error!
```

**Utilisez `const` quand :**
- La r√©f√©rence ne doit pas changer
- Pour la plupart de vos variables (par d√©faut)
- Pour les fonctions, objets, tableaux

<Callout type="warning" title="const avec objets/tableaux">
**Important :** `const` emp√™che la **r√©assignation**, pas la **mutation** !

```javascript
const user = { name: 'Alice' };
user.name = 'Bob'; // ‚úÖ OK (mutation)
user = {}; // ‚ùå Error (r√©assignation)

const numbers = [1, 2, 3];
numbers.push(4); // ‚úÖ OK (mutation)
numbers = []; // ‚ùå Error (r√©assignation)
```

`const` prot√®ge la **r√©f√©rence**, pas le **contenu**.
</Callout>

## R√®gle d'or

<Callout type="success" title="Bonne pratique">
1. **Toujours utiliser `const` par d√©faut**
2. Passer √† `let` seulement si vous devez r√©assigner
3. **Ne jamais utiliser `var`** (code obsol√®te)

```javascript
// ‚úÖ Bon
const name = 'Alice';
let score = 0;
score = score + 10;

// ‚ùå Mauvais
var name = 'Alice'; // OBSOL√àTE
var score = 0;
```
</Callout>
